FIFO：First In First Out，先进先出。判断被存储的时间，离目前最远的数据优先被淘汰。
LRU：Least Recently Used，最近最少使用。判断最近被使用的时间，目前最远的数据优先被淘汰。
LFU：Least Frequently Used，最不经常使用。在一段时间内，数据被使用次数最少的，优先被淘汰。

LFU系列算法:
LFU
原理:
    LFU: 根据数据的历史访问频率来淘汰数据,其核心思想是"如果数据过去被访问多次,那么将来被访问
的频率也更高"

实现: LFU的每个数据块都有一个引用计数,所有数据块按照引用计数排序,具有相同引用计数
的数据块则按照时间排序
1. 新加入数据插入到队列尾部(因为引用计数为1)
2. 队列中的数据被访问后,引用计数增加,队列重新排序
3. 当需要淘汰数据时,将已经排序的列表最后的数据块删除

命中率: 一般情况下,LFU效率要优于LRU,且能够避免周期性或者偶发性的操作导致缓存命中率
下降的问题.但LFU需要记录数据的历史访问记录,一旦数据访问模式改变,LFU需要更长时间来适应
新的访问模式,即: LFU存在历史数据影响将来数据的"缓存污染"效用

复杂度:
需要维护一个队列记录所有数据的访问记录,每个数据都需要维护引用计数


LFU-Aging
原理:
    基于LFU的改进算法,其核心思想是"除了访问次数外,还要考虑访问时间".这样做的主要原因
是解决LFU缓存污染的问题.

实现:
    虽然LFU-Aging考虑时间因素,但其算法并不直接记录数据的访问时间,而是通过平均引用计数来
标识时间.
    LFU-Aging在LFU的基础上,增加了一个最大平均引用计数. 当当前缓存的数据"引用计数平均值"
达到或者超过"最大平均引用计数"时,则将所有数据的引用计数都减少.减少的方法有多种,可以直接
减为原来的一半,也可以减去固定的值等.

命中率:
    LFU-Aging的效率和LFU类似,当访问模式改变时,LFU-Aging能够更快的使用新的数据访问
模式,效率要高.

复杂度:
    在LFU的基础上增加平均引用次数判断和处理

代价:
    和LFU类似,当平均引用次数超过指定阈值(Aging)后,需要遍历访问列表


Window-LFU:
    window-LFU是LFU的一个改进版,差别在于window-LFU并不记录所有数据的访问历史, 而
只是记录过去一段时间内的访问历史,这就是window的由来,基于这个原因,传统的LFU又被称为
"Perfect-LFU"
实现:
    与LFU的实现基本相同,差别在于不需要记录所有数据的历史访问数据,而只记录过去一段时间内
的访问历史.

假设历史访问记录长度设为9，缓存大小为3，图中不同颜色代表针对不同数据块的访问，同一颜色代表针对同一数据的多次访问。
样例1：黄色访问3次，蓝色和橘色都是两次，橘色更新，因此缓存黄色、橘色、蓝色三个数据块

样例2：绿色访问3次，蓝色两次，暗红两次，蓝色更新，因此缓存绿色、蓝色、暗红三个数据块

代价:
    Window-LFU只记录一部分的访问历史记录,不需要记录所有的数据访问历史,因此内存消耗
和排序消耗都比LFU要低.

















