hash散列表

解决冲突的方法:
    给定初始容量,当装载因子大于0.75时,进行扩容两倍,然后重新哈希
1. 开放定址法(再散列法)
    线性探测在散列、二次探测再散列、伪随机探测再散列
2. 再哈希
    同时构造多个不同的哈希函数, Hi = RH1(key) i = 1, 2, ..., k
    当哈希地址Hi = RH1(key)发生冲突时,再计算Hi=RH2(key)......,
    直到冲突不再发生.这种方法不易产生聚集,但增加了计算时间

3. 链地址法
    这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，
    并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。
    链地址法适用于经常进行插入和删除的情况。

Java中HashMap原理就是初始容量是16, 数组+链表或红黑树构成
JDK1.8链表长度大于8时引入了红黑树
缺点: 存不了大数据,线程不安全(put)
ConcurrentHashMap: 分段锁,不会影响整个table,只会影响hash值一样

数据库表数据量小于2000,不要建立索引,直接使用全表遍历

二叉搜索树又叫二叉查找树,它具有一下特点:
1. 如果它的左子树不为空,则左子树上节点的值都小于根节点
2. 如果它的右子树不为空,则右子树上节点的值都大于根节点
3. 子树同样也要遵循以上两点
只要一棵树是二叉搜索树,那么它的中序遍历一定是有序的
查找时间复杂度: O(log n)
平衡树: 基于二叉排序树,为了防止退化成链表(左旋右旋)

索引是怎么支撑千万级表的快速查找:
Mysql衡量查询效率: 磁盘IO次数
为什么不用红黑树而用B+树作为mysql的索引结构?
一般来说索引非常大,尤其是关系型数据库这种数据量大的索引能达到亿级别,
所以为了减少内存的占用,索引也会被存储在磁盘上.B+树只有叶节点存放数据
,其余节点用来索引, 每层节点数目非常多,层数很少,目的就是为了减少磁盘IO
次数.
红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁,进而导致效率低下
的情况.


11.10




























