hash散列表

解决冲突的方法:
    给定初始容量,当装载因子大于0.75时,进行扩容两倍,然后重新哈希
1. 开放定址法(再散列法)
    线性探测在散列、二次探测再散列、伪随机探测再散列
2. 再哈希
    同时构造多个不同的哈希函数, Hi = RH1(key) i = 1, 2, ..., k
    当哈希地址Hi = RH1(key)发生冲突时,再计算Hi=RH2(key)......,
    直到冲突不再发生.这种方法不易产生聚集,但增加了计算时间

3. 链地址法
    这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，
    并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。
    链地址法适用于经常进行插入和删除的情况。

Java中HashMap原理就是初始容量是16, 数组+链表或红黑树构成
JDK1.8链表长度大于8时引入了红黑树
缺点: 存不了大数据,线程不安全(put)
ConcurrentHashMap: 分段锁,不会影响整个table,只会影响hash值一样

数据库表数据量小于2000,不要建立索引,直接使用全表遍历

二叉搜索树又叫二叉查找树,它具有以下特点:
1. 如果它的左子树不为空,则左子树上节点的值都小于根节点
2. 如果它的右子树不为空,则右子树上节点的值都大于根节点
3. 子树同样也要遵循以上两点
只要一棵树是二叉搜索树,那么它的中序遍历一定是有序的
查找时间复杂度: O(log n)
平衡树: 基于二叉排序树,为了防止退化成链表(左旋右旋)

索引是怎么支撑千万级表的快速查找:
Mysql衡量查询效率: 磁盘IO次数
为什么不用红黑树而用B+树作为mysql的索引结构?
一般来说索引非常大,尤其是关系型数据库这种数据量大的索引能达到亿级别,
所以为了减少内存的占用,索引也会被存储在磁盘上.B+树只有叶节点存放数据
,其余节点用来索引, 每层节点数目非常多,层数很少,目的就是为了减少磁盘IO
次数.
红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁,进而导致效率低下
的情况.

Mysql索引为什么不使用Btree?
由于所有的节点都可能包含目标数据，我们总是要从根节点向下遍历子树查找满足条件的数据行，
这个特点带来了大量的随机 I/O，也是 B 树最大的性能问题。
B+ 树中就不存在这个问题了，因为所有的数据行都存储在叶节点中，而这些叶节点可以
通过『指针』依次按顺序连接，当我们在如下所示的 B+ 树遍历数据时可以直接在多个子
节点之间进行跳转，这样能够节省大量的磁盘 I/O 时间，也不需要在不同层级的节点之间
对数据进行拼接和排序；通过一个 B+ 树最左侧的叶子节点，我们可以像链表一样遍历整个
树中的全部数据，我们也可以引入双向链表保证倒序遍历时的性能


Btree创建过程
M阶的Btree的几个重要特性:
1. 节点最多含有m颗子树(指针),m-1个关键字(数据)(m>=2)
2. 除根节点和叶子节点外,其他每个节点至少有ceil(m/2)个子节点, ceil为向上取整
3. 若根节点不是叶子节点,则至少有两颗子树
Btree插入的时候通过分裂保持特点




























