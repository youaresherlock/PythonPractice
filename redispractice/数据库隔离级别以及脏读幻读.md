MYSQL数据库事务隔离级别主要有四种: Serializable: 串行化,一个事务一个事务的执行 Serializable会在读取的每张表上加锁，所以可能导致大量的超时和锁竞争的问题 。实际应用中很少用到这一级别。 加锁范围：锁表

Repeatable read: 可重复读,无论其他事务是否修改并提交了数据,在这个事务 中看到看到的数据值始终不受其他事务影响 如果检索条件有索引（包括主键索引）的时候，默认加锁方式是next-key 锁； 如果检索条件没有索引，更新数据时会锁住整张表。一个间隙被事务加了锁， 其他事务是不能在这个间隙插入记录的，这样可以防止幻读。 间隙锁(Gap Lock)是Innodb在可重复读提交下为了解决幻读问题时引入的锁机制

Read Committed: 读取已提交,其他事务提交了对数据的修改后,本事务就能读取到 修改后的数据值 已提交读（read committed ）：只能读取到已经提交的数据，可以避免脏读。已提交读不能保证可重复读，也就是说，前后两次读取，会获取到不同的结果集。这里的不同结果集可能包含两种情况：

1，结果集行数不一致，insert和delete导致的。（幻读）

2，结果集中的某些记录不一致，update导致的。（不可重复读） 加锁范围：行锁，只锁修改的行。比如我的update语句只修改一行记录，那么只锁这一行。 读已提交能够保证：我修改的10条数据，在我这个事务中，不会被其他事务改变。 读已提交不能保证：我读取的100条数据，在我这个事务中始终不变。

Read uncommitted: 读取未提交,其他事务只要修改了数据,即使未提交,本事务 也能看到修改后的数据值. 加锁范围: 不加锁 什么都不保证 MYSQL数据库默认使用可重复度(Repeatable read)

使用乐观锁的时候，如果一个事务修改了库存并提交了事务，那其他的事务应该可 以读取到修改后的数据值，所以不能使用可重复读的隔离级别，应该修改为 读取已提交（Read committed）。

读取未提交 可能出现脏读、幻读 不可重复读

读取已提交 可能出现幻读 不可重复度

可重复读 可能出现幻读

串行化