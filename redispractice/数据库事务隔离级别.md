事务隔离级别指的是在处理同一个数据的多个事务中,一个事务修改数据后,其他事务
何时能看到修改后的结果 

MYSQL数据库事务隔离级别主要有四种:
Serializable: 串行化,一个事务一个事务的执行 
Serializable会在读取的每张表上加锁，所以可能导致大量的超时和锁竞争的问题
。实际应用中很少用到这一级别。
加锁范围：锁表


Repeatable read: 可重复读,无论其他事务是否修改并提交了数据,在这个事务
中看到看到的数据值始终不受其他事务影响 
如果检索条件有索引（包括主键索引）的时候，默认加锁方式是next-key 锁；
如果检索条件没有索引，更新数据时会锁住整张表。一个间隙被事务加了锁，
其他事务是不能在这个间隙插入记录的，这样可以防止幻读。
间隙锁(Gap Lock)是Innodb在可重复读提交下为了解决幻读问题时引入的锁机制


Read Committed: 读取已提交,其他事务提交了对数据的修改后,本事务就能读取到
修改后的数据值
已提交读（read committed ）：只能读取到已经提交的数据，可以避免脏读。已提交读不能保证可重复读，也就是说，前后两次读取，会获取到不同的结果集。这里的不同结果集可能包含两种情况：

1，结果集行数不一致，insert和delete导致的。（幻读）

2，结果集中的某些记录不一致，update导致的。（不可重复读）
加锁范围：行锁，只锁修改的行。比如我的update语句只修改一行记录，那么只锁这一行。
读已提交能够保证：我修改的10条数据，在我这个事务中，不会被其他事务改变。
读已提交不能保证：我读取的100条数据，在我这个事务中始终不变。


Read uncommitted: 读取未提交,其他事务只要修改了数据,即使未提交,本事务
也能看到修改后的数据值. 
加锁范围: 不加锁 什么都不保证
MYSQL数据库默认使用可重复度(Repeatable read)

使用乐观锁的时候，如果一个事务修改了库存并提交了事务，那其他的事务应该可
以读取到修改后的数据值，所以不能使用可重复读的隔离级别，应该修改为
读取已提交（Read committed）。



读取未提交 可能出现脏读、幻读  不可重复读

读取已提交 可能出现幻读  不可重复度

可重复读  可能出现幻读

串行化 
























